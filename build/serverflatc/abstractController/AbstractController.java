/* * Copyright (c) 2015. * 游戏服务器核心代码编写人石头哥哥拥有使用权 * 最终使用解释权归创心科技所有 * 联系方式：E-mail:13638363871@163.com ; * 个人博客主页：http://my.oschina.net/chenleijava * powered by 石头哥哥 */package com.dc.gameserver.servercore.controller.abstractController;import com.dc.gameserver.model.character.PlayerInstance;import com.google.flatbuffers.FlatBufferBuilder;import com.google.protobuf.CodedOutputStream;import com.google.protobuf.MessageLite;import io.netty.buffer.ByteBuf;import io.netty.buffer.PooledByteBufAllocator;import io.netty.buffer.Unpooled;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.annotation.PostConstruct;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.charset.Charset;/** * @author :陈磊 <br/> *         Date: 13-1-2<br/> *         Time: 下午12:49<br/> *         connectMethod:13638363871@163.com<br/> *         数据包分解操作类 *         数据包协议类型：1.包长+包类型+包体（消息部分） *         1）包体：length+msg+length+msg ... ... *         注意：操作ChannelBuffer的getxx()方式，method does not modify readerIndex *         readXXX(),writeXX(),将会改变读写指针 *         数据分解可选择方式如下： *         1）采用fastjson/jackson/gason序列化为javaBean *         2）解析字节流（优先） *         注意buf释放：1、 parseObject(ByteBuf buffer,Class clazz)序列化为javabean之后； *         2、如果没有调用parseObject(ByteBuf buffer,Class clazz)，直接处理buf数据，记得释放内存; *         <p/> *         <p/> *         游戏中采用的数据包长读为4字节，因为项目历史原因，所以在writeShort中使用了4字节构建数据包。 */@SuppressWarnings("unchecked")public abstract class AbstractController implements IController {    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractController.class);    //default capacity is 64;    private static final int DEFAULT_INITIAL_CAPACITY = 0x40;    /**     * spring 容器初始化 加载并初始化相应控制器处理句柄     */    @PostConstruct    public abstract void PostConstruct();    /**     * 数据分发     *     * @param buffer 数据载体     * @param player active object     * @throws Exception     */    @Deprecated    public void DispatchByteBuffer(final ByteBuf buffer, final PlayerInstance player) throws Exception {    }    /**     * 释放buf 资源     *     * @param byteBuf     */    public static void releaseBuf(ByteBuf byteBuf) {        byteBuf.release();        byteBuf = null;    }    /**     * 基于flatBuffers 结构数据传输     *     * @param data   cast subclass of table .     * @param player game session     * @throws Exception     */    @Override    @Deprecated    public void DispatchFlatBuffer(byte[] data, PlayerInstance player) throws Exception {    }    /**     * wrap byte to ByteBuffer for transfer to table!     * get data from  byte buffer ,more fast!!!     *     * @param data     * @return     */    public ByteBuffer wrapData(byte[] data) {        // offset is 4. msgID occupy 4 byte        return ByteBuffer.wrap(data, 4, data.length - 4);    }    /**     * 创建ByteBuffer  heapBuffer     *     * @return PoolByteBuffer     * <p/>     * capacity        DEFAULT_INITIAL_CAPACITY = 256;     */    public static ByteBuf createPoolByteBuffer() {        return PooledByteBufAllocator.DEFAULT.heapBuffer();    }    /**     * 创建ByteBuffer  heapBuffer     *     * @param capacity 指定大小 64 字节     * @return PoolByteBuffer     */    public static ByteBuf createPoolByteBuffer(int capacity) {        return PooledByteBufAllocator.DEFAULT.heapBuffer(capacity);    }    /**     * @param capacity     * @param maxCapacity     * @return     */    public static ByteBuf createePoolByteBuffer(int capacity, int maxCapacity) {        return PooledByteBufAllocator.DEFAULT.heapBuffer(capacity, maxCapacity);    }    /**     * 创建直接缓冲byteBuffer     *     * @return     */    public static ByteBuf createPoolDircetlyByteBuffer() {        return PooledByteBufAllocator.DEFAULT.directBuffer();    }    /**     * 创建指定大小的直接缓冲区byteBuffer     *     * @param capacity     * @return     */    public static ByteBuf createPoolDircetlyByteBuffer(int capacity) {        return PooledByteBufAllocator.DEFAULT.directBuffer(capacity);    }    /**     * 创建ByteBuffer  heapBuffer     * Unpooled     *     * @return ByteBuf     */    public static ByteBuf createUnpoolByteBuffer() {        return createUnpoolByteBuffer(DEFAULT_INITIAL_CAPACITY);    }    /**     * 创建ByteBuffer  heapBuffer     *     * @param capacity 指定大小     * @return ByteBuf     */    public static ByteBuf createUnpoolByteBuffer(int capacity) {        return Unpooled.buffer(capacity);    }    /**     * 创建ByteBuffer  heapBuffer     *     * @param byteBuf 指定大小     * @return ByteBuf     */    public static ByteBuf createByteBuffer(ByteBuf byteBuf) {        return createByteBuffer(byteBuf, DEFAULT_INITIAL_CAPACITY);    }    /**     * 创建buf   默认是heap buf     *     * @param byteBuf     * @param capacity 创建buffer大小     * @return     */    public static ByteBuf createByteBuffer(ByteBuf byteBuf, int capacity) {        return byteBuf.alloc().heapBuffer(capacity);    }    /**     * 释放资源     *     * @param buf     */    public static void release(ByteBuf buf) {        buf.release();    }    /**     *    解析数据包buffer操作方式 字节流 </br>     *      1）包体：length+msg+length+msg ... ...    </br>     *******************************************************************************************/    /**     * read a byte (1 code)     *     * @param buffer buffer     * @return byte     */    public static byte readByte(ByteBuf buffer) {        return buffer.readByte();    }    /**     * read a short (2 code)     *     * @param buffer buffer     * @return short     */    public static short readShort(ByteBuf buffer) {        return buffer.readShort();    }    /**     * read a short (4 code)     *     * @param buffer buffer     * @return int     */    public static int readInt(ByteBuf buffer) {        return buffer.readInt();    }    /**     * @param buffer 待处理数据缓存区        </br>     * @return message     * 如果默认读取1字节长度的字符串，那么该方法传入buffer将直接返回相应的字符串   </br>     */    public static String readStringUTF8(ByteBuf buffer) {        int length = buffer.readByte();        ByteBuf dataBuffer = buffer.readBytes(length);        return dataBuffer.toString(Charset.forName("UTF-8"));    }    /**     * @param buffer 待处理数据缓存区     * @param length 读取指定的数据长度     * @return message     */    public static String readStringUTF8(ByteBuf buffer, int length) {        ByteBuf dataBuffer = buffer.readBytes(length);        return dataBuffer.toString(Charset.forName("UTF-8"));  //To change body of implemented methods use File | Settings | File Templates.    }    /**     * @param buffer 待处理数据缓存区     </br>     * @return message     * 如果默认读取1字节长度的字符串，那么该方法传入buffer将直接返回相应的字符串        </br>     */    public static String readString2(ByteBuf buffer) {        int len = buffer.readByte();        String str = buffer.toString(buffer.readerIndex(), len, Charset.forName("UTF-8"));        buffer.skipBytes(len);        return str;    }    /**     * 解析数据包类型包体：length+msg+length+msg ... ...</br>     * 数据长，注意要跳过                </br>     * 此函数和readString(ChannelBuffer buffer, int length）功能一样的       </br>     *     * @param buffer 待处理数据缓存区   </br>     * @param len    数据长度               </br>     * @return     */    public static String readString2(ByteBuf buffer, int len) {        String str = buffer.toString(buffer.readerIndex(), len, Charset.forName("UTF-8"));        buffer.skipBytes(len);        return str;    }    /**     * 以gbk编码解析数据string     *     * @param buffer buffer     * @param length length     * @return String     * 返回GBK编码     */    public static String readStringGBK(ByteBuf buffer, int length) {        ByteBuf dataBuffer = buffer.readBytes(length);        return dataBuffer.toString(Charset.forName("gbk"));    }    /**     * 基于flatbuffer 作为传输 序列化方案     *     * @param ID     * @param builder     * @return ByteBuf     */    public static ByteBuf wrappedBufferInt(int ID, FlatBufferBuilder builder) {        byte[] data = builder.sizedByteArray();        int length = data.length + 0x8;// packageLength+(msgID+data.length)  == 4+4+dataLength        ByteBuf buffer = PooledByteBufAllocator.DEFAULT.heapBuffer(length, length);        buffer.setIndex(0, 0x4);//设定writeIndex指针位置    4        buffer.writeInt(ID); //编号                4        buffer.writeBytes(data);        buffer.setInt(0, buffer.writerIndex() - 0x4); //设置包长度        // for gc        builder = null;        data = null;        return buffer;    }    /**     * encode message     * Encoder buffer             </br>     * 包长度2字节                   </br>     *     * @param ID          数据包编号    </br>     * @param messageLite proto     * @return     */    public static ByteBuf wrappedBufferInt(int ID, MessageLite messageLite) {        if (LOGGER.isDebugEnabled()) {            LOGGER.debug("下行消息 ID：" + ID + "\n " + messageLite.toString());        }        int serializedSize = messageLite.getSerializedSize();//data size        byte[] result = new byte[serializedSize];        CodedOutputStream output = CodedOutputStream.newInstance(result);        try {            messageLite.writeTo(output); // write data to byte array        } catch (IOException e) {            e.printStackTrace();        }        int length = 0x8 + serializedSize;        //encode message        ByteBuf buffer = PooledByteBufAllocator.DEFAULT.heapBuffer(length, length);        buffer.setIndex(0, 0x4);//setIndex        buffer.writeInt(ID); //write message ID                4        buffer.writeBytes(result); //write bytes        buffer.setInt(0, buffer.writerIndex() - 0x4);//set package length        // for GC        messageLite = null;        result = null;        output = null;        return buffer;   // netty will  release it    }    /**     * 解码buffer  toByteArray                       </br>     *     * @param buffer buffer                     </br>     * @return byte[]     */    public static byte[] BufferToByteArray(ByteBuf buffer) {        if (buffer == null)            return null;        return buffer.array();    }}